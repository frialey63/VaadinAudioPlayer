<link rel="import" href="src/client-stream-buffer.html">
<link rel="import" href="src/client-stream.html">
<link rel="import" href="src/audio-stream-player.html">

<!--
NOTE: this element has nothing to show on the screen, so the template is
not needed. Let us skip the template and leave the `dom-module` empty.
-->
<dom-module id="audio-player"></dom-module>

<script>
    class AudioPlayer extends Polymer.Element {
        constructor() {
            super();

            // Safari has webkitAudioContext
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this._context = new AudioContext();

            // Safari requires resuming the context from an user-originated
            // event listener, e. g., on click
            const safariResumeAudioOnClick = () => {
                if (this._context.state !== 'running') {
                    const resumeListener = () => {
                        window.removeEventListener('click', resumeListener);
                        this._context.resume();
                    };
                    window.addEventListener('click', resumeListener);
                }
            };
            safariResumeAudioOnClick();

            // Safari can suspend the audio, detect and apply the resume trick
            this._context.addEventListener('statechange', safariResumeAudioOnClick);
        }

        static get is() {
            return 'audio-player';
        }

        static get properties() {
            return {
                chunks: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                chunkTimeMillis: Number,
                duration: Number,
                numChunksPreload: Number,
                effects: Array,
                reportPositionRepeatTime: {
                    type: Number,
                    value: 500
                },
                _reportPositionRepeatInterval: Number,
                _lastPlaybackPosition: Number
            };
        }

        static get observers() {
            return [
                '_updateStream(chunks, chunkTimeMillis)'
            ];
        }

        connectedCallback() {
            super.connectedCallback();
            if (this._player) {
                this._player.connect(this._context.destination);
            }
        }

        disconnectedCallback() {
            super.disconnectedCallback();
            if (this._player) {
                this.stopPlayback();
                this._player.disconnect();
            }
        }

        _updateStream(chunks, chunkTimeMillis) {
            if (chunks === undefined || chunkTimeMillis === undefined) {
                return;
            }

            if (this._player) {
                this._player.disconnect();
                this._player.onStop = undefined;
            }

            // console.table(chunks);

            this._stream = new VaadinAudioPlayer.ClientStream(this._context, this);
            this._player = new VaadinAudioPlayer.AudioStreamPlayer(this._context, this._stream, this.chunkTimeMillis);
            this._player.connect(this._context.destination);
            this._player.onStop = () => {
                this.$server.reportPlaybackStopped();
                // this.$server.reportPlaybackPosition(this._player.position);
                this._cancelPositionReportSchedule();
            };
        }

        /**
         * @param {number} chunkId
         * @param {boolean} compressed
         * @param {string} encodedData
         */
        sendData(chunkId, compressed, encodedData) {
            /**
             * Method borrowed from
             * http://blog.danguer.com/2011/10/24/base64-binary-decoding-in-javascript/
             *
             * @returns {ArrayBuffer}
             */
            function decodeBase64(str) {
                var Base64Binary = {
                    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

                    decodeArrayBuffer: function(input) {
                        var bytes = (input.length/4) * 3;
                        var ab = new ArrayBuffer(bytes);
                        this.decode(input, ab);

                        return ab;
                    },

                    removePaddingChars: function(input){
                        var lkey = this._keyStr.indexOf(input.charAt(input.length - 1));
                        if(lkey == 64){
                            return input.substring(0,input.length - 1);
                        }
                        return input;
                    },

                    decode: function (input, arrayBuffer) {
                        //get last chars to see if are valid
                        input = this.removePaddingChars(input);
                        input = this.removePaddingChars(input);

                        var bytes = parseInt((input.length / 4) * 3, 10);

                        var uarray;
                        var chr1, chr2, chr3;
                        var enc1, enc2, enc3, enc4;
                        var i = 0;
                        var j = 0;

                        if (arrayBuffer)
                            uarray = new Uint8Array(arrayBuffer);
                        else
                            uarray = new Uint8Array(bytes);

                        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

                        for (i=0; i<bytes; i+=3) {
                            //get the 3 octects in 4 ascii chars
                            enc1 = this._keyStr.indexOf(input.charAt(j++));
                            enc2 = this._keyStr.indexOf(input.charAt(j++));
                            enc3 = this._keyStr.indexOf(input.charAt(j++));
                            enc4 = this._keyStr.indexOf(input.charAt(j++));

                            chr1 = (enc1 << 2) | (enc2 >> 4);
                            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                            chr3 = ((enc3 & 3) << 6) | enc4;

                            uarray[i] = chr1;
                            if (enc3 != 64) uarray[i+1] = chr2;
                            if (enc4 != 64) uarray[i+2] = chr3;
                        }

                        return uarray;
                    }
                };

                return Base64Binary.decodeArrayBuffer(str);
            };

            // console.warn('NAP received chunk', chunkId);
            const data = decodeBase64(encodedData);
            // console.warn(URL.createObjectURL(
            //     new Blob([data], {type: 'audio/wav'})
            // ));
            const buffer = new VaadinAudioPlayer.ClientStreamBuffer(this._context, data);
            this._stream.notifyChunkLoaded(chunkId, buffer);
        }

        /**
         * @param {number} startTime
         * @param {number} endTime
         */
        requestAndCacheAudioChunks(startTime, endTime) {
            for (let i = startTime; i < endTime; i += this._chunkTimeMillis) {
                this._stream.requestChunkByTimestamp(i);
            }
        }

        /**
         * @param {number} position_millis
         */
        setPlaybackPosition(position_millis) {
            // console.warn("set position", position_millis);
            // this.$server.reportPlaybackPosition(position_millis);
            this._player.position = Math.max(0, position_millis);
        }

        /**
         * @param {number} delta_millis
         */
        skipPosition(delta_millis) {
            this.setPlaybackPosition(delta_millis);
        }

        startPlayback() {
            // console.warn('NAP element startPlayback');
            this.$server.reportPlaybackStarted();
            this._player.play();
            this._schedulePositionReport();
        }

        pausePlayback() {
            // console.warn('NAP element pausePlayback');
            this._player.pause();
            this.$server.reportPlaybackPosition(this._player.position);
            this.$server.reportPlaybackPaused();
            this._cancelPositionReportSchedule();
        }

        resumePlayback() {
            // console.warn('NAP element resumePlayback');
            this._player.resume();
            this.$server.reportPlaybackStarted();
            this._schedulePositionReport();
        }

        stopPlayback() {
            // console.warn('NAP element stopPlayback');
            this._player.stop();
            this._cancelPositionReportSchedule();
        }

        _schedulePositionReport() {
            this._cancelPositionReportSchedule();
            this._reportPositionRepeatInterval = window.setInterval(() => {
                const position = this._player && this._player.position;
                if (position !== this._lastPlaybackPosition) {
                    this.$server.reportPlaybackPosition(position);
                    this._lastPlaybackPosition = position;
                }
            }, this.reportPositionRepeatTime);
        }

        _cancelPositionReportSchedule() {
            if (this._reportPositionRepeatInterval) {
                window.clearInterval(this._reportPositionRepeatInterval);
                this._reportPositionRepeatInterval = undefined;
            }
        }

        /**
         * @param {number} speed_multiplier
         */
        setPlaybackSpeed(speed_multiplier) {
            this._player.playbackSpeed = speed_multiplier;
        }

        /**
         * @param {number} volume
         */
        setVolume(volume) {
            this.$server.reportVolumeChange(volume);
            this._player.volume = volume;
        }

        /**
         * @param {number} volume
         * @param {number} channel
         */
        setVolumeOnChannel(volume, channel) {
            this._player.setVolumeOnChannel(volume, channel);
        }

        /**
         * @param {number} balance
         */
        setBalance(balance) {
            this._player.balance = balance;
        }
    }
    customElements.define(AudioPlayer.is, AudioPlayer);

</script>
